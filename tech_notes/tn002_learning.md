# Learning from human feedback

* **Author**: Jeremy Lewi
* **Last Updated**: 2024-04-23
* **Status**: Being Drafted

## Objective

Allow Foyle to learn from human feedback.

## TL;DR

If a user corrects a command generated by the AI, we want to be able to use that feedback to improve the AI.
The simplest way to do this is using RAG. We will use a multi step process

- Generate the documents
- Ingest the documents

The reason for having two steps is to be able to easily augment the set of documents generated using other means.

## Background: Weaviate

This section summarizes some key behaviors of Weaviate that will influence our design.

### IDs

Objects in Weaviate are [defined by a UUID](https://weaviate.io/developers/weaviate/manage-data/create#generate-deterministic-ids).
UUIDs can be manually assigned to objects at creation time or you can let Weaviate assign one. Weaviate deterministically
assigns UUIDs to Objects so the same data generates the same UUID.

### Properties

Weaviate is composed of collections where each [Collection](https://weaviate.io/developers/weaviate/config-refs/schema#vectorindextype)
defines the schema of some object. Collections were formerly referred to as Class.
A collection is defined by set of [properties](https://weaviate.io/developers/weaviate/config-refs/schema#properties).
Notably properties can have [object datatype](https://weaviate.io/developers/weaviate/config-refs/datatypes#introduction).
The primary function of [properties](https://weaviate.io/developers/weaviate/config-refs/schema#properties) is to
control how data is indexed and queried.


## Generate Documents

The first step of learning from human feedback is to generate documents that can be used to train the AI.
We can add a command to the Foyle CLI to generate these documents

```bash
foyle learn create docs --output=/path/to/dir
```

### Documents based on mistakes

We can generate documents from past mistakes. The [block logs](tn001_logging.md) provide a record of how each block
was generated and executed. If the executed block is different from the generated block then the AI made a mistake
that we should try to correct. The simplest document we could create is a document consisting of the blocks
sent to the AI and the block that was actually generated.

### Weaviate Schema Design

How do we map data structures into documents stored in Weaviate?

Here's a schema defined as a GoLang struct for how we represent documents in a collection.

```Go

type DBObject struct {
	// Query is the text that will be vectorized and used in similarity search.
	Query string
	
	Name string
	Namespace string
	// Data is a serialized representation of the complete document.
    Data string	
}
```

So I think it only makes sense to define properties for fields we explicitly
want to query on. We can use a field of type `text` or `blob` to store a serialized version of our document. 

So a key design decision is whether we try to mirror our Document schema in Weaviate properties or 
we just use a single property to store 


What are some options?

* We have one property corresponding to the data that will be vectorized and used for the query
  * We   

[semantic indexing](https://weaviate.io/developers/weaviate/config-refs/schema#configure-semantic-indexing)
* We should disable vectorizePropertyName
* We should disable vectorizeClassName

* How do we handle duplicates. 

## References
[Weaviate Schemas](https://weaviate.io/developers/weaviate/config-refs/schema)

